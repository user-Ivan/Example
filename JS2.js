function testPrime(num1) { //ф-я проверки числа на простоту
    var testPr = true; //флаг 
    for (var i = 2; i < num1; i++) { //цикл по нашему числу
        if ((num1 % i) == 0) { //проверка деления на все его множители
            testPr = false; //если один из них, делится без остатка
            break; //то проверку не прошел и выходим из цикла
        }
    }
    return testPr; //возврат проверки простое/составное
}

function algoEuclid(num1, num2) { //ф-я проверки взаимопростоты
    var testEu = false, //флаг проверки 
        a = Math.max(num1, num2), //выбирается большее число
        b = Math.min(num1, num2), //выбирается меньшее число
        c = 0; //пер-я для хранения остака
    do { //цикл под нахождения остатка
        c = a % b; //находим остаток от деления
        a = b; //сдвигаем последовательность далее
        b = c;
        if (c == 1) //если остаток был равер 1
            testEu = true; //то числа взаимопростые
    }
    while (c != 0) //выполняется пока остаток не достигнет нуля
    return testEu; //возврат проверки взаимпопростые или нет
}

function funReverseNumber(num, mod) { //ф-я нахождени обратного элемента по модулю
    if ((num == 0) || (algoEuclid(num, mod) == false)) //проверка условий сущ-я ОЭ
        return 'Обратного элемента не существует';
    var reverseNum = 1; //начало перебора с единицы
    while (((reverseNum * num) % mod) != 1) //проверка условий равенства
        reverseNum++; //переход к слеюущем числу
    return reverseNum; //возврат ОЭ
}

function myPow(num, exp, mod) { //ф-я возведения num в степень exp и вычисления по модулю mod по итерациям
    var c = 1; //пер-я для хранения остатков
    for (var i = 0; i < exp; i++) { //цикл по степени
        c = (c * num) % mod; //умножаем на число и вычисляем модуль
    } //сохраняем остаток и умножаем его на число в след итерации 
    return c; //полученный остаток
}

function funGetK(modul) { //ф-я проверки условий для числа K
    var kInFun = prompt('Введите случайное взаимопростое число:');
    //принцип проверки. есть условия проверки, и если хоть один из них нарушен, то нужно проходить
    //все проверки заново, в приоритетном порядке. Например, если ввдоится не взаимопростое число, то
    //попросят ввести его еще раз, но проверка начнется с допустимых границ, а потом на взаимопростоту
    do { //цикл проверки
        var testOpenKey = true; //флаг теста
        if (((kInFun > 1) && (kInFun <= modul - 1)) == 0) { //проверка границ введеного ключа
            kInFun = prompt('Введеное число не в рамках. Введите число заново:'); //в противном случа, вводим заново
            testOpenKey = false; //флаг теста указывает что нужно проти проверку еще раз
        }
        if (testOpenKey == true) { //проверка флага теста
            if (algoEuclid(kInFun, modul) == false) { //проверка на взаимопростоту
                kInFun = prompt('Введеное число не взаимопростое. Введите число заново:');
                testOpenKey = false; //флаг теста указывает что нужно проти проверку еще раз
            }
        }
    } while (testOpenKey == false) //пока все тесты не будут продейны без проблем
    return kInFun;
}

function funDecipherText(cipherText, modul, closeKey) { //ф-я дешифрования текста
    var reverseFirstPartText = funReverseNumber(myPow(cipherText.charCodeAt(0), closeKey, modul), modul); //берем первуюю часть шифротекста и находим ОЭ
    var decipherTextInFun = ''; //переменная для хранения зашифрованного текста
    for (var i = 1; i < cipherText.length; i++) { //проходим по всем символам полученного текста
        decipherTextInFun += String.fromCharCode((cipherText.charCodeAt(i) * reverseFirstPartText) % modul);
    } //берется код символа,  умножается на ОЭ и вычисляется по модулю
    //потом преобразовывается по полученому юни-коду к символу и склеивается в дешифр-ю строчку
    return decipherTextInFun; //дешифрованый текст
}

function funCipherText(getText, openKey, k, modul) { //ф-я шифрования текста
    var cipherTextInFun = String.fromCharCode(firstPartText); //переменная для хранения зашифрованного текста и добавляем сразу первую часть шифротекста
    for (var i = 0; i < getText.length; i++) { //проходим по всем символам полученного текста
        cipherTextInFun += String.fromCharCode((getText.charCodeAt(i) * myPow(openKey, k, modul)) % modul);
    } //открытый ключ возводится в степень числа К и вычисляется остаток по modul
    //умножается на код символа и вычисляется по modul
    //потом преобразовывается по полученому юни-коду к символу и склеивается в зашифр-ю строчку
    return cipherTextInFun; //зашифрованый текст
}

////////////////////////  Начало алгоритма ширования Эль-Гамаля
////////////////////////  Ходит Игрок В
{
    var modul = prompt('Игрок В \nВведите большое простое число:');
    while (testPrime(modul) == false) { //проверка на простоту
        modul = prompt('Введеное число не простое. Введите число заново:');
    }

    var g = prompt('Игрок В \nВведите ПЕРВОЕ большое целое число:');
    while ((+g >= +modul)) { //проверка допустимых границ
        g = prompt(`Введеное число выходит за [0; ${modul}). Введите число заново:`);
    }

    var closeKey = prompt('Игрок В \nВведите ВТОРОЕ большое целое число:');
    while ((+closeKey >= +modul)) { //проверка допустимых границ
        closeKey = prompt(`Введеное число выходит за [0; ${modul}). Введите число заново:`);
    }

    var openKey = myPow(g, closeKey, modul); //вычисляем открытй ключ

    alert(`Игрок В ---> Игроку А \np = ${modul}\ng = ${g}\nОткрытый ключ = ${openKey}`); //передаем Игроку А открытые данные
}

////////////////////////  Ходит Игрок А
{
    var getText = prompt('Игрок А \nВведите текст для передачи:');
    if (getText != null) { //если нажата "отмена", то не будет окна повторного ввода
        while (getText == '') { //проверка на наличие сообщения
            getText = prompt('Ничего не введено. Введите еще раз:');
        }
    }

    var k = funGetK(modul); //выбираем число К

    var firstPartText = myPow(g, k, modul); //вычисляем первую часть шифротекста

    var cipherText = funCipherText(getText, openKey, k, modul); //шифруем текст
    alert(cipherText); //вывод зашифрованного текста
}

////////////////////////  Ходит Игрок В
{
    var decipherText = funDecipherText(cipherText, modul, closeKey); //дешифруем текст
    alert(decipherText); //вывод дешифрованного текста
}
